The qualification of the facebook hackercup 2013
================================================

https://www.facebook.com/hackercup/problems.php?round=185564241586420

资格赛，题目不是很难。
- 第一题就是一个简单的排序问题，
- 第二题是一个标准的动态规划的题目，
- 第三题比较有意思，想了一会，写了一个O(k)的算法，稍后会详细说明


Problem A: Beautiful strings
--------------------------
### 题目大意

 给字母a->z编码为数字1-26（数字和字母一一映射）,使得给定字符串的编码后的和最大

### Solution 
 贪心。
 统计每个字母出现的次数，安装出现次数从多到小，编码位26->1.
 隐含的数学知识：给定非负数组[x1,...,xn], [y1,...,yn], 求一个1-n的排列[k1,..., kn]
 使得 sum (x_i * y_(k_i)) 最大。
 试着证明，数组x,y 按照从大到小的顺序，向乘求和，和最大。

Problem B: Balanced Smileys
--------------------------
### 题目大意
 给定一些将基本的字串生成规则，判断给定字符串是否满足这些规则

### Solution 
 动态规划。 
 最主要的变换规则是： c =  a + b; c = (a);
 状态记录 status[i][j]
 标识起点为i，长度为j的字符串是否满足规则；则两条规则对应状态转移为：
 - status[i][j] |= str[i] = ( & status[i+1][j-2] & str[i+j-1] = )
 - status[i][j] |= status[i][k] & status[i + k][ j - k];  0 < k < j

 Problem C: Find the Min
--------------------------
### 题目大意
 给定一个数组的前k项，生成数组后面的n-k项，生成规则是：对于每一项 i(k< i < n),
 i项是在i前面k项里面没出现的过得非负整数。举个例子：k = 3; 2, 4, 1
 那么第四项就是：0, (前三项是： 2，4, 1);
 那么第五项就是：2, (前三项是： 4, 1, 0);
 那么第六项就是：3, (前三项是： 1, 0, 2);
 
### Solution 
 找规律和对队列的理解.
 
 从上面的例子往后面找 : 2, 4, 1 -> | 0 -> 2 -> 3 -> 1 | -> 0 -> 2 -> 3 -> 1 |
 发现后面是一个(k+1)的循环。怎么证明呢
 (1) 区间[k+1, 2*k+1]必然是[0,  k]的排列。反正法证明。
 (2) 区间[x +1, 2*x +1] (x >= k)也必然是一个[0, k]的排列
 (3) 区间[2k +1, 3k+1] == [k+1, 2*k + 1]

 题目要求的第n个元素, n很大，通过(k+1)循环节，把问题转为求数组[k+1, 2*k +1]元素
 k < 10^5。规则元素生成规则，问题有转化未怎么快速做两个基本操作：
 - 快速求没在k个元素出现过的最小的非负整数
 - 快速添加一个元素
 - 快速删除一个元素(对应于数组下标往后移动，排除最开头元素的约束）
 
a, 简单做法用一个[0-k] count 数组记录每个元素出现的次数，删除就是counter[x]-1;
对于每个i, 从0到大 开始检测，看那个元素没有出现，就添加，同时couner[x]
+1;复杂度 o(k^2), 肯定超时

b, 再来看一下有没有优化的空间。每次从头开始检测是一个很大的浪费，建设当前检测到的元素是
x, 删除的元素是y， 后选元素肯定是在x, y里面选。（为什么？）
如果y < x 且 counter[y] ==0,  选 y； 否则选 x
这样复杂度就将为 O(k) 了

